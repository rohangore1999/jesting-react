{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { CancelledError, Console, functionalUpdate, isCancelable, isCancelledError, isDocumentVisible, isOnline, isServer, isValidTimeout, noop, replaceEqualDeep, sleep } from './utils';\nimport { QueryStatus } from './types';\nimport { QueryObserver } from './queryObserver';\nimport { notifyManager } from './notifyManager'; // TYPES\n\nfunction _empty() {}\n\nvar ActionType = {\n  Failed: 0,\n  Fetch: 1,\n  Success: 2,\n  Error: 3,\n  Invalidate: 4\n}; // CLASS\n\nfunction _awaitIgnored(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty) : Promise.resolve();\n  }\n}\n\nfunction _invoke(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nfunction _await(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nexport var Query = /*#__PURE__*/function () {\n  function Query(config) {\n    this.config = config;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.queryCache = config.queryCache;\n    this.cacheTime = config.cacheTime;\n    this.observers = [];\n    this.state = getDefaultState(config);\n    this.scheduleGc();\n  }\n\n  var _proto = Query.prototype;\n\n  _proto.updateConfig = function updateConfig(config) {\n    this.config = config;\n    this.cacheTime = Math.max(this.cacheTime, config.cacheTime);\n  };\n\n  _proto.dispatch = function dispatch(action) {\n    var _this = this;\n\n    this.state = queryReducer(this.state, action);\n    notifyManager.batch(function () {\n      _this.observers.forEach(function (observer) {\n        observer.onQueryUpdate(action);\n      });\n\n      _this.queryCache.notifyGlobalListeners(_this);\n    });\n  };\n\n  _proto.scheduleGc = function scheduleGc() {\n    var _this2 = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearGcTimeout();\n\n    if (this.observers.length > 0 || !isValidTimeout(this.cacheTime)) {\n      return;\n    }\n\n    this.gcTimeout = setTimeout(function () {\n      _this2.remove();\n    }, this.cacheTime);\n  };\n\n  _proto.cancel = function cancel(silent) {\n    var promise = this.promise;\n\n    if (promise && this.cancelFetch) {\n      this.cancelFetch(silent);\n      return promise.then(noop).catch(noop);\n    }\n\n    return Promise.resolve(undefined);\n  };\n\n  _proto.continue = function _continue() {\n    var _this$continueFetch;\n\n    (_this$continueFetch = this.continueFetch) == null ? void 0 : _this$continueFetch.call(this);\n  };\n\n  _proto.clearTimersObservers = function clearTimersObservers() {\n    this.observers.forEach(function (observer) {\n      observer.clearTimers();\n    });\n  };\n\n  _proto.clearGcTimeout = function clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  };\n\n  _proto.setData = function setData(updater, options) {\n    var _this$config$isDataEq, _this$config;\n\n    var prevData = this.state.data; // Get the new data\n\n    var data = functionalUpdate(updater, prevData); // Use prev data if an isDataEqual function is defined and returns `true`\n\n    if ((_this$config$isDataEq = (_this$config = this.config).isDataEqual) == null ? void 0 : _this$config$isDataEq.call(_this$config, prevData, data)) {\n      data = prevData;\n    } else if (this.config.structuralSharing) {\n      // Structurally share data between prev and new data if needed\n      data = replaceEqualDeep(prevData, data);\n    } // Try to determine if more data can be fetched\n\n\n    var canFetchMore = hasMorePages(this.config, data); // Set data and mark it as cached\n\n    this.dispatch({\n      type: ActionType.Success,\n      data: data,\n      canFetchMore: canFetchMore,\n      updatedAt: options == null ? void 0 : options.updatedAt\n    });\n  }\n  /**\n   * @deprecated\n   */\n  ;\n\n  _proto.clear = function clear() {\n    Console.warn('react-query: clear() has been deprecated, please use remove() instead');\n    this.remove();\n  };\n\n  _proto.remove = function remove() {\n    this.queryCache.removeQuery(this);\n  };\n\n  _proto.destroy = function destroy() {\n    this.clearGcTimeout();\n    this.clearTimersObservers();\n    this.cancel();\n  };\n\n  _proto.isActive = function isActive() {\n    return this.observers.some(function (observer) {\n      return observer.config.enabled;\n    });\n  };\n\n  _proto.isStale = function isStale() {\n    return this.state.isInvalidated || this.state.status !== QueryStatus.Success || this.observers.some(function (observer) {\n      return observer.getCurrentResult().isStale;\n    });\n  };\n\n  _proto.isStaleByTime = function isStaleByTime(staleTime) {\n    if (staleTime === void 0) {\n      staleTime = 0;\n    }\n\n    return this.state.isInvalidated || this.state.status !== QueryStatus.Success || this.state.updatedAt + staleTime <= Date.now();\n  };\n\n  _proto.onInteraction = function onInteraction(type) {\n    // Execute the first observer which is enabled,\n    // stale and wants to refetch on this interaction.\n    var staleObserver = this.observers.find(function (observer) {\n      var config = observer.config;\n\n      var _observer$getCurrentR = observer.getCurrentResult(),\n          isStale = _observer$getCurrentR.isStale;\n\n      return config.enabled && (type === 'focus' && (config.refetchOnWindowFocus === 'always' || config.refetchOnWindowFocus && isStale) || type === 'online' && (config.refetchOnReconnect === 'always' || config.refetchOnReconnect && isStale));\n    });\n\n    if (staleObserver) {\n      staleObserver.fetch();\n    } // Continue any paused fetch\n\n\n    this.continue();\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.subscribe = function subscribe(listener) {\n    var observer = new QueryObserver(this.config);\n    observer.subscribe(listener);\n    return observer;\n  };\n\n  _proto.subscribeObserver = function subscribeObserver(observer) {\n    this.observers.push(observer); // Stop the query from being garbage collected\n\n    this.clearGcTimeout();\n  };\n\n  _proto.unsubscribeObserver = function unsubscribeObserver(observer) {\n    this.observers = this.observers.filter(function (x) {\n      return x !== observer;\n    });\n\n    if (!this.observers.length) {\n      // If the transport layer does not support cancellation\n      // we'll let the query continue so the result can be cached\n      if (this.isTransportCancelable) {\n        this.cancel();\n      }\n\n      this.scheduleGc();\n    }\n  };\n\n  _proto.invalidate = function invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: ActionType.Invalidate\n      });\n    }\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.refetch = function refetch(options, config) {\n    var promise = this.fetch(undefined, config);\n\n    if (!(options == null ? void 0 : options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.fetchMore = function fetchMore(fetchMoreVariable, options, config) {\n    return this.fetch({\n      fetchMore: {\n        fetchMoreVariable: fetchMoreVariable,\n        previous: (options == null ? void 0 : options.previous) || false\n      }\n    }, config);\n  };\n\n  _proto.fetch = function fetch(options, config) {\n    try {\n      var _exit2 = false;\n\n      var _this4 = this;\n\n      return _invoke(function () {\n        if (_this4.promise) {\n          return function () {\n            if ((options == null ? void 0 : options.fetchMore) && _this4.state.data) {\n              // Silently cancel current fetch if the user wants to fetch more\n              return _awaitIgnored(_this4.cancel(true));\n            } else {\n              // Return current promise if we are already fetching\n              _exit2 = true;\n              return _this4.promise;\n            }\n          }();\n        }\n      }, function (_result2) {\n        if (_exit2) return _result2; // Update config if passed, otherwise the config from the last execution is used\n\n        if (config) {\n          _this4.updateConfig(config);\n        }\n\n        config = _this4.config; // Get the query function params\n\n        var filter = config.queryFnParamsFilter;\n        var params = filter ? filter(_this4.queryKey) : _this4.queryKey;\n        _this4.promise = _async(function () {\n          return _catch(function () {\n            var data;\n            return _invoke(function () {\n              if (config.infinite) {\n                return _await(_this4.startInfiniteFetch(config, params, options), function (_this4$startInfiniteF) {\n                  data = _this4$startInfiniteF;\n                });\n              } else {\n                return _await(_this4.startFetch(config, params, options), function (_this4$startFetch) {\n                  data = _this4$startFetch;\n                });\n              }\n            }, function () {\n              // Set success state\n              _this4.setData(data); // Cleanup\n\n\n              delete _this4.promise; // Return data\n\n              return data;\n            });\n          }, function (error) {\n            // Set error state if needed\n            if (!(isCancelledError(error) && error.silent)) {\n              _this4.dispatch({\n                type: ActionType.Error,\n                error: error\n              });\n            } // Log error\n\n\n            if (!isCancelledError(error)) {\n              Console.error(error);\n            } // Cleanup\n\n\n            delete _this4.promise; // Propagate error\n\n            throw error;\n          });\n        })();\n        return _this4.promise;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.startFetch = function startFetch(config, params, _options) {\n    // Create function to fetch the data\n    var fetchData = function fetchData() {\n      return config.queryFn.apply(config, params);\n    }; // Set to fetching state if not already in it\n\n\n    if (!this.state.isFetching) {\n      this.dispatch({\n        type: ActionType.Fetch\n      });\n    } // Try to fetch the data\n\n\n    return this.tryFetchData(config, fetchData);\n  };\n\n  _proto.startInfiniteFetch = function startInfiniteFetch(config, params, options) {\n    var fetchMore = options == null ? void 0 : options.fetchMore;\n\n    var _ref = fetchMore || {},\n        previous = _ref.previous,\n        fetchMoreVariable = _ref.fetchMoreVariable;\n\n    var isFetchingMore = fetchMore ? previous ? 'previous' : 'next' : false;\n    var prevPages = this.state.data || []; // Create function to fetch a page\n\n    var fetchPage = _async(function (pages, prepend, cursor) {\n      var lastPage = getLastPage(pages, prepend);\n\n      if (typeof cursor === 'undefined' && typeof lastPage !== 'undefined' && config.getFetchMore) {\n        cursor = config.getFetchMore(lastPage, pages);\n      }\n\n      return !Boolean(cursor) && typeof lastPage !== 'undefined' ? pages : _await(config.queryFn.apply(config, params.concat([cursor])), function (page) {\n        return prepend ? [page].concat(pages) : [].concat(pages, [page]);\n      });\n    }); // Create function to fetch the data\n\n\n    var fetchData = function fetchData() {\n      if (isFetchingMore) {\n        return fetchPage(prevPages, previous, fetchMoreVariable);\n      } else if (!prevPages.length) {\n        return fetchPage([]);\n      } else {\n        var promise = fetchPage([]);\n\n        for (var i = 1; i < prevPages.length; i++) {\n          promise = promise.then(fetchPage);\n        }\n\n        return promise;\n      }\n    }; // Set to fetching state if not already in it\n\n\n    if (!this.state.isFetching || this.state.isFetchingMore !== isFetchingMore) {\n      this.dispatch({\n        type: ActionType.Fetch,\n        isFetchingMore: isFetchingMore\n      });\n    } // Try to get the data\n\n\n    return this.tryFetchData(config, fetchData);\n  };\n\n  _proto.tryFetchData = function tryFetchData(config, fn) {\n    var _this5 = this;\n\n    return new Promise(function (outerResolve, outerReject) {\n      var resolved = false;\n      var continueLoop;\n      var cancelTransport;\n\n      var done = function done() {\n        resolved = true;\n        delete _this5.cancelFetch;\n        delete _this5.continueFetch;\n        delete _this5.isTransportCancelable; // End loop if currently paused\n\n        continueLoop == null ? void 0 : continueLoop();\n      };\n\n      var resolve = function resolve(value) {\n        done();\n        outerResolve(value);\n      };\n\n      var reject = function reject(value) {\n        done();\n        outerReject(value);\n      }; // Create callback to cancel this fetch\n\n\n      _this5.cancelFetch = function (silent) {\n        reject(new CancelledError(silent));\n        cancelTransport == null ? void 0 : cancelTransport();\n      }; // Create callback to continue this fetch\n\n\n      _this5.continueFetch = function () {\n        continueLoop == null ? void 0 : continueLoop();\n      }; // Create loop function\n\n\n      var run = _async(function () {\n        return _catch(function () {\n          // Execute query\n          var promiseOrValue = fn(); // Check if the transport layer support cancellation\n\n          if (isCancelable(promiseOrValue)) {\n            cancelTransport = function cancelTransport() {\n              try {\n                promiseOrValue.cancel();\n              } catch (_unused) {}\n            };\n\n            _this5.isTransportCancelable = true;\n          } // Await data\n\n\n          return _await(promiseOrValue, function (_promiseOrValue) {\n            resolve(_promiseOrValue);\n          });\n        }, function (error) {\n          // Stop if the fetch is already resolved\n          if (resolved) {\n            return;\n          } // Do we need to retry the request?\n\n\n          var failureCount = _this5.state.failureCount;\n          var retry = config.retry,\n              retryDelay = config.retryDelay;\n          var shouldRetry = retry === true || failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n          if (!shouldRetry) {\n            // We are done if the query does not need to be retried\n            reject(error);\n            return;\n          } // Increase the failureCount\n\n\n          _this5.dispatch({\n            type: ActionType.Failed\n          }); // Delay\n\n\n          return _await(sleep(functionalUpdate(retryDelay, failureCount) || 0), function () {\n            // Pause retry if the document is not visible or when the device is offline\n            return _invoke(function () {\n              if (!isDocumentVisible() || !isOnline()) {\n                return _awaitIgnored(new Promise(function (continueResolve) {\n                  continueLoop = continueResolve;\n                }));\n              }\n            }, function () {\n              if (!resolved) {\n                run();\n              }\n            }); // Try again if not resolved yet\n          });\n        });\n      }); // Start loop\n\n\n      run();\n    });\n  };\n\n  return Query;\n}();\n\nfunction getLastPage(pages, previous) {\n  return previous ? pages[0] : pages[pages.length - 1];\n}\n\nfunction hasMorePages(config, pages, previous) {\n  if (config.infinite && config.getFetchMore && Array.isArray(pages)) {\n    return Boolean(config.getFetchMore(getLastPage(pages, previous), pages));\n  }\n}\n\nfunction getDefaultState(config) {\n  var data = typeof config.initialData === 'function' ? config.initialData() : config.initialData;\n  var status = typeof data !== 'undefined' ? QueryStatus.Success : config.enabled ? QueryStatus.Loading : QueryStatus.Idle;\n  return {\n    canFetchMore: hasMorePages(config, data),\n    data: data,\n    error: null,\n    failureCount: 0,\n    isFetching: status === QueryStatus.Loading,\n    isFetchingMore: false,\n    isInitialData: true,\n    isInvalidated: false,\n    status: status,\n    updateCount: 0,\n    updatedAt: Date.now()\n  };\n}\n\nexport function queryReducer(state, action) {\n  var _action$updatedAt;\n\n  switch (action.type) {\n    case ActionType.Failed:\n      return _extends({}, state, {\n        failureCount: state.failureCount + 1\n      });\n\n    case ActionType.Fetch:\n      return _extends({}, state, {\n        failureCount: 0,\n        isFetching: true,\n        isFetchingMore: action.isFetchingMore || false,\n        status: typeof state.data !== 'undefined' ? QueryStatus.Success : QueryStatus.Loading\n      });\n\n    case ActionType.Success:\n      return _extends({}, state, {\n        canFetchMore: action.canFetchMore,\n        data: action.data,\n        error: null,\n        failureCount: 0,\n        isFetching: false,\n        isFetchingMore: false,\n        isInitialData: false,\n        isInvalidated: false,\n        status: QueryStatus.Success,\n        updateCount: state.updateCount + 1,\n        updatedAt: (_action$updatedAt = action.updatedAt) != null ? _action$updatedAt : Date.now()\n      });\n\n    case ActionType.Error:\n      return _extends({}, state, {\n        error: action.error,\n        failureCount: state.failureCount + 1,\n        isFetching: false,\n        isFetchingMore: false,\n        status: QueryStatus.Error,\n        throwInErrorBoundary: true,\n        updateCount: state.updateCount + 1\n      });\n\n    case ActionType.Invalidate:\n      return _extends({}, state, {\n        isInvalidated: true\n      });\n\n    default:\n      return state;\n  }\n}","map":{"version":3,"names":["_extends","CancelledError","Console","functionalUpdate","isCancelable","isCancelledError","isDocumentVisible","isOnline","isServer","isValidTimeout","noop","replaceEqualDeep","sleep","QueryStatus","QueryObserver","notifyManager","_empty","ActionType","Failed","Fetch","Success","Error","Invalidate","_awaitIgnored","value","direct","then","Promise","resolve","_invoke","body","result","_await","_catch","recover","e","_async","f","args","i","arguments","length","apply","reject","Query","config","queryKey","queryHash","queryCache","cacheTime","observers","state","getDefaultState","scheduleGc","_proto","prototype","updateConfig","Math","max","dispatch","action","_this","queryReducer","batch","forEach","observer","onQueryUpdate","notifyGlobalListeners","_this2","clearGcTimeout","gcTimeout","setTimeout","remove","cancel","silent","promise","cancelFetch","catch","undefined","continue","_continue","_this$continueFetch","continueFetch","call","clearTimersObservers","clearTimers","clearTimeout","setData","updater","options","_this$config$isDataEq","_this$config","prevData","data","isDataEqual","structuralSharing","canFetchMore","hasMorePages","type","updatedAt","clear","warn","removeQuery","destroy","isActive","some","enabled","isStale","isInvalidated","status","getCurrentResult","isStaleByTime","staleTime","Date","now","onInteraction","staleObserver","find","_observer$getCurrentR","refetchOnWindowFocus","refetchOnReconnect","fetch","subscribe","listener","subscribeObserver","push","unsubscribeObserver","filter","x","isTransportCancelable","invalidate","refetch","throwOnError","fetchMore","fetchMoreVariable","previous","_exit2","_this4","_result2","queryFnParamsFilter","params","infinite","startInfiniteFetch","_this4$startInfiniteF","startFetch","_this4$startFetch","error","_options","fetchData","queryFn","isFetching","tryFetchData","_ref","isFetchingMore","prevPages","fetchPage","pages","prepend","cursor","lastPage","getLastPage","getFetchMore","Boolean","concat","page","fn","_this5","outerResolve","outerReject","resolved","continueLoop","cancelTransport","done","run","promiseOrValue","_unused","_promiseOrValue","failureCount","retry","retryDelay","shouldRetry","continueResolve","Array","isArray","initialData","Loading","Idle","isInitialData","updateCount","_action$updatedAt","throwInErrorBoundary"],"sources":["/Users/rohangore/Documents/jesting-react/node_modules/react-query/es/core/query.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { CancelledError, Console, functionalUpdate, isCancelable, isCancelledError, isDocumentVisible, isOnline, isServer, isValidTimeout, noop, replaceEqualDeep, sleep } from './utils';\nimport { QueryStatus } from './types';\nimport { QueryObserver } from './queryObserver';\nimport { notifyManager } from './notifyManager'; // TYPES\n\nfunction _empty() {}\n\nvar ActionType = {\n  Failed: 0,\n  Fetch: 1,\n  Success: 2,\n  Error: 3,\n  Invalidate: 4\n};\n\n// CLASS\nfunction _awaitIgnored(value, direct) {\n  if (!direct) {\n    return value && value.then ? value.then(_empty) : Promise.resolve();\n  }\n}\n\nfunction _invoke(body, then) {\n  var result = body();\n\n  if (result && result.then) {\n    return result.then(then);\n  }\n\n  return then(result);\n}\n\nfunction _await(value, then, direct) {\n  if (direct) {\n    return then ? then(value) : value;\n  }\n\n  if (!value || !value.then) {\n    value = Promise.resolve(value);\n  }\n\n  return then ? value.then(then) : value;\n}\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction _async(f) {\n  return function () {\n    for (var args = [], i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    try {\n      return Promise.resolve(f.apply(this, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nexport var Query = /*#__PURE__*/function () {\n  function Query(config) {\n    this.config = config;\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    this.queryCache = config.queryCache;\n    this.cacheTime = config.cacheTime;\n    this.observers = [];\n    this.state = getDefaultState(config);\n    this.scheduleGc();\n  }\n\n  var _proto = Query.prototype;\n\n  _proto.updateConfig = function updateConfig(config) {\n    this.config = config;\n    this.cacheTime = Math.max(this.cacheTime, config.cacheTime);\n  };\n\n  _proto.dispatch = function dispatch(action) {\n    var _this = this;\n\n    this.state = queryReducer(this.state, action);\n    notifyManager.batch(function () {\n      _this.observers.forEach(function (observer) {\n        observer.onQueryUpdate(action);\n      });\n\n      _this.queryCache.notifyGlobalListeners(_this);\n    });\n  };\n\n  _proto.scheduleGc = function scheduleGc() {\n    var _this2 = this;\n\n    if (isServer) {\n      return;\n    }\n\n    this.clearGcTimeout();\n\n    if (this.observers.length > 0 || !isValidTimeout(this.cacheTime)) {\n      return;\n    }\n\n    this.gcTimeout = setTimeout(function () {\n      _this2.remove();\n    }, this.cacheTime);\n  };\n\n  _proto.cancel = function cancel(silent) {\n    var promise = this.promise;\n\n    if (promise && this.cancelFetch) {\n      this.cancelFetch(silent);\n      return promise.then(noop).catch(noop);\n    }\n\n    return Promise.resolve(undefined);\n  };\n\n  _proto.continue = function _continue() {\n    var _this$continueFetch;\n\n    (_this$continueFetch = this.continueFetch) == null ? void 0 : _this$continueFetch.call(this);\n  };\n\n  _proto.clearTimersObservers = function clearTimersObservers() {\n    this.observers.forEach(function (observer) {\n      observer.clearTimers();\n    });\n  };\n\n  _proto.clearGcTimeout = function clearGcTimeout() {\n    if (this.gcTimeout) {\n      clearTimeout(this.gcTimeout);\n      this.gcTimeout = undefined;\n    }\n  };\n\n  _proto.setData = function setData(updater, options) {\n    var _this$config$isDataEq, _this$config;\n\n    var prevData = this.state.data; // Get the new data\n\n    var data = functionalUpdate(updater, prevData); // Use prev data if an isDataEqual function is defined and returns `true`\n\n    if ((_this$config$isDataEq = (_this$config = this.config).isDataEqual) == null ? void 0 : _this$config$isDataEq.call(_this$config, prevData, data)) {\n      data = prevData;\n    } else if (this.config.structuralSharing) {\n      // Structurally share data between prev and new data if needed\n      data = replaceEqualDeep(prevData, data);\n    } // Try to determine if more data can be fetched\n\n\n    var canFetchMore = hasMorePages(this.config, data); // Set data and mark it as cached\n\n    this.dispatch({\n      type: ActionType.Success,\n      data: data,\n      canFetchMore: canFetchMore,\n      updatedAt: options == null ? void 0 : options.updatedAt\n    });\n  }\n  /**\n   * @deprecated\n   */\n  ;\n\n  _proto.clear = function clear() {\n    Console.warn('react-query: clear() has been deprecated, please use remove() instead');\n    this.remove();\n  };\n\n  _proto.remove = function remove() {\n    this.queryCache.removeQuery(this);\n  };\n\n  _proto.destroy = function destroy() {\n    this.clearGcTimeout();\n    this.clearTimersObservers();\n    this.cancel();\n  };\n\n  _proto.isActive = function isActive() {\n    return this.observers.some(function (observer) {\n      return observer.config.enabled;\n    });\n  };\n\n  _proto.isStale = function isStale() {\n    return this.state.isInvalidated || this.state.status !== QueryStatus.Success || this.observers.some(function (observer) {\n      return observer.getCurrentResult().isStale;\n    });\n  };\n\n  _proto.isStaleByTime = function isStaleByTime(staleTime) {\n    if (staleTime === void 0) {\n      staleTime = 0;\n    }\n\n    return this.state.isInvalidated || this.state.status !== QueryStatus.Success || this.state.updatedAt + staleTime <= Date.now();\n  };\n\n  _proto.onInteraction = function onInteraction(type) {\n    // Execute the first observer which is enabled,\n    // stale and wants to refetch on this interaction.\n    var staleObserver = this.observers.find(function (observer) {\n      var config = observer.config;\n\n      var _observer$getCurrentR = observer.getCurrentResult(),\n          isStale = _observer$getCurrentR.isStale;\n\n      return config.enabled && (type === 'focus' && (config.refetchOnWindowFocus === 'always' || config.refetchOnWindowFocus && isStale) || type === 'online' && (config.refetchOnReconnect === 'always' || config.refetchOnReconnect && isStale));\n    });\n\n    if (staleObserver) {\n      staleObserver.fetch();\n    } // Continue any paused fetch\n\n\n    this.continue();\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.subscribe = function subscribe(listener) {\n    var observer = new QueryObserver(this.config);\n    observer.subscribe(listener);\n    return observer;\n  };\n\n  _proto.subscribeObserver = function subscribeObserver(observer) {\n    this.observers.push(observer); // Stop the query from being garbage collected\n\n    this.clearGcTimeout();\n  };\n\n  _proto.unsubscribeObserver = function unsubscribeObserver(observer) {\n    this.observers = this.observers.filter(function (x) {\n      return x !== observer;\n    });\n\n    if (!this.observers.length) {\n      // If the transport layer does not support cancellation\n      // we'll let the query continue so the result can be cached\n      if (this.isTransportCancelable) {\n        this.cancel();\n      }\n\n      this.scheduleGc();\n    }\n  };\n\n  _proto.invalidate = function invalidate() {\n    if (!this.state.isInvalidated) {\n      this.dispatch({\n        type: ActionType.Invalidate\n      });\n    }\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.refetch = function refetch(options, config) {\n    var promise = this.fetch(undefined, config);\n\n    if (!(options == null ? void 0 : options.throwOnError)) {\n      promise = promise.catch(noop);\n    }\n\n    return promise;\n  }\n  /**\n   * @deprectated\n   */\n  ;\n\n  _proto.fetchMore = function fetchMore(fetchMoreVariable, options, config) {\n    return this.fetch({\n      fetchMore: {\n        fetchMoreVariable: fetchMoreVariable,\n        previous: (options == null ? void 0 : options.previous) || false\n      }\n    }, config);\n  };\n\n  _proto.fetch = function fetch(options, config) {\n    try {\n      var _exit2 = false;\n\n      var _this4 = this;\n\n      return _invoke(function () {\n        if (_this4.promise) {\n          return function () {\n            if ((options == null ? void 0 : options.fetchMore) && _this4.state.data) {\n              // Silently cancel current fetch if the user wants to fetch more\n              return _awaitIgnored(_this4.cancel(true));\n            } else {\n              // Return current promise if we are already fetching\n              _exit2 = true;\n              return _this4.promise;\n            }\n          }();\n        }\n      }, function (_result2) {\n        if (_exit2) return _result2;\n\n        // Update config if passed, otherwise the config from the last execution is used\n        if (config) {\n          _this4.updateConfig(config);\n        }\n\n        config = _this4.config; // Get the query function params\n\n        var filter = config.queryFnParamsFilter;\n        var params = filter ? filter(_this4.queryKey) : _this4.queryKey;\n        _this4.promise = _async(function () {\n          return _catch(function () {\n            var data;\n            return _invoke(function () {\n              if (config.infinite) {\n                return _await(_this4.startInfiniteFetch(config, params, options), function (_this4$startInfiniteF) {\n                  data = _this4$startInfiniteF;\n                });\n              } else {\n                return _await(_this4.startFetch(config, params, options), function (_this4$startFetch) {\n                  data = _this4$startFetch;\n                });\n              }\n            }, function () {\n              // Set success state\n              _this4.setData(data); // Cleanup\n\n\n              delete _this4.promise; // Return data\n\n              return data;\n            });\n          }, function (error) {\n            // Set error state if needed\n            if (!(isCancelledError(error) && error.silent)) {\n              _this4.dispatch({\n                type: ActionType.Error,\n                error: error\n              });\n            } // Log error\n\n\n            if (!isCancelledError(error)) {\n              Console.error(error);\n            } // Cleanup\n\n\n            delete _this4.promise; // Propagate error\n\n            throw error;\n          });\n        })();\n        return _this4.promise;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.startFetch = function startFetch(config, params, _options) {\n    // Create function to fetch the data\n    var fetchData = function fetchData() {\n      return config.queryFn.apply(config, params);\n    }; // Set to fetching state if not already in it\n\n\n    if (!this.state.isFetching) {\n      this.dispatch({\n        type: ActionType.Fetch\n      });\n    } // Try to fetch the data\n\n\n    return this.tryFetchData(config, fetchData);\n  };\n\n  _proto.startInfiniteFetch = function startInfiniteFetch(config, params, options) {\n    var fetchMore = options == null ? void 0 : options.fetchMore;\n\n    var _ref = fetchMore || {},\n        previous = _ref.previous,\n        fetchMoreVariable = _ref.fetchMoreVariable;\n\n    var isFetchingMore = fetchMore ? previous ? 'previous' : 'next' : false;\n    var prevPages = this.state.data || []; // Create function to fetch a page\n\n    var fetchPage = _async(function (pages, prepend, cursor) {\n      var lastPage = getLastPage(pages, prepend);\n\n      if (typeof cursor === 'undefined' && typeof lastPage !== 'undefined' && config.getFetchMore) {\n        cursor = config.getFetchMore(lastPage, pages);\n      }\n\n      return !Boolean(cursor) && typeof lastPage !== 'undefined' ? pages : _await(config.queryFn.apply(config, params.concat([cursor])), function (page) {\n        return prepend ? [page].concat(pages) : [].concat(pages, [page]);\n      });\n    }); // Create function to fetch the data\n\n\n    var fetchData = function fetchData() {\n      if (isFetchingMore) {\n        return fetchPage(prevPages, previous, fetchMoreVariable);\n      } else if (!prevPages.length) {\n        return fetchPage([]);\n      } else {\n        var promise = fetchPage([]);\n\n        for (var i = 1; i < prevPages.length; i++) {\n          promise = promise.then(fetchPage);\n        }\n\n        return promise;\n      }\n    }; // Set to fetching state if not already in it\n\n\n    if (!this.state.isFetching || this.state.isFetchingMore !== isFetchingMore) {\n      this.dispatch({\n        type: ActionType.Fetch,\n        isFetchingMore: isFetchingMore\n      });\n    } // Try to get the data\n\n\n    return this.tryFetchData(config, fetchData);\n  };\n\n  _proto.tryFetchData = function tryFetchData(config, fn) {\n    var _this5 = this;\n\n    return new Promise(function (outerResolve, outerReject) {\n      var resolved = false;\n      var continueLoop;\n      var cancelTransport;\n\n      var done = function done() {\n        resolved = true;\n        delete _this5.cancelFetch;\n        delete _this5.continueFetch;\n        delete _this5.isTransportCancelable; // End loop if currently paused\n\n        continueLoop == null ? void 0 : continueLoop();\n      };\n\n      var resolve = function resolve(value) {\n        done();\n        outerResolve(value);\n      };\n\n      var reject = function reject(value) {\n        done();\n        outerReject(value);\n      }; // Create callback to cancel this fetch\n\n\n      _this5.cancelFetch = function (silent) {\n        reject(new CancelledError(silent));\n        cancelTransport == null ? void 0 : cancelTransport();\n      }; // Create callback to continue this fetch\n\n\n      _this5.continueFetch = function () {\n        continueLoop == null ? void 0 : continueLoop();\n      }; // Create loop function\n\n\n      var run = _async(function () {\n        return _catch(function () {\n          // Execute query\n          var promiseOrValue = fn(); // Check if the transport layer support cancellation\n\n          if (isCancelable(promiseOrValue)) {\n            cancelTransport = function cancelTransport() {\n              try {\n                promiseOrValue.cancel();\n              } catch (_unused) {}\n            };\n\n            _this5.isTransportCancelable = true;\n          } // Await data\n\n\n          return _await(promiseOrValue, function (_promiseOrValue) {\n            resolve(_promiseOrValue);\n          });\n        }, function (error) {\n          // Stop if the fetch is already resolved\n          if (resolved) {\n            return;\n          } // Do we need to retry the request?\n\n\n          var failureCount = _this5.state.failureCount;\n          var retry = config.retry,\n              retryDelay = config.retryDelay;\n          var shouldRetry = retry === true || failureCount < retry || typeof retry === 'function' && retry(failureCount, error);\n\n          if (!shouldRetry) {\n            // We are done if the query does not need to be retried\n            reject(error);\n            return;\n          } // Increase the failureCount\n\n\n          _this5.dispatch({\n            type: ActionType.Failed\n          }); // Delay\n\n\n          return _await(sleep(functionalUpdate(retryDelay, failureCount) || 0), function () {\n            // Pause retry if the document is not visible or when the device is offline\n            return _invoke(function () {\n              if (!isDocumentVisible() || !isOnline()) {\n                return _awaitIgnored(new Promise(function (continueResolve) {\n                  continueLoop = continueResolve;\n                }));\n              }\n            }, function () {\n              if (!resolved) {\n                run();\n              }\n            }); // Try again if not resolved yet\n          });\n        });\n      }); // Start loop\n\n\n      run();\n    });\n  };\n\n  return Query;\n}();\n\nfunction getLastPage(pages, previous) {\n  return previous ? pages[0] : pages[pages.length - 1];\n}\n\nfunction hasMorePages(config, pages, previous) {\n  if (config.infinite && config.getFetchMore && Array.isArray(pages)) {\n    return Boolean(config.getFetchMore(getLastPage(pages, previous), pages));\n  }\n}\n\nfunction getDefaultState(config) {\n  var data = typeof config.initialData === 'function' ? config.initialData() : config.initialData;\n  var status = typeof data !== 'undefined' ? QueryStatus.Success : config.enabled ? QueryStatus.Loading : QueryStatus.Idle;\n  return {\n    canFetchMore: hasMorePages(config, data),\n    data: data,\n    error: null,\n    failureCount: 0,\n    isFetching: status === QueryStatus.Loading,\n    isFetchingMore: false,\n    isInitialData: true,\n    isInvalidated: false,\n    status: status,\n    updateCount: 0,\n    updatedAt: Date.now()\n  };\n}\n\nexport function queryReducer(state, action) {\n  var _action$updatedAt;\n\n  switch (action.type) {\n    case ActionType.Failed:\n      return _extends({}, state, {\n        failureCount: state.failureCount + 1\n      });\n\n    case ActionType.Fetch:\n      return _extends({}, state, {\n        failureCount: 0,\n        isFetching: true,\n        isFetchingMore: action.isFetchingMore || false,\n        status: typeof state.data !== 'undefined' ? QueryStatus.Success : QueryStatus.Loading\n      });\n\n    case ActionType.Success:\n      return _extends({}, state, {\n        canFetchMore: action.canFetchMore,\n        data: action.data,\n        error: null,\n        failureCount: 0,\n        isFetching: false,\n        isFetchingMore: false,\n        isInitialData: false,\n        isInvalidated: false,\n        status: QueryStatus.Success,\n        updateCount: state.updateCount + 1,\n        updatedAt: (_action$updatedAt = action.updatedAt) != null ? _action$updatedAt : Date.now()\n      });\n\n    case ActionType.Error:\n      return _extends({}, state, {\n        error: action.error,\n        failureCount: state.failureCount + 1,\n        isFetching: false,\n        isFetchingMore: false,\n        status: QueryStatus.Error,\n        throwInErrorBoundary: true,\n        updateCount: state.updateCount + 1\n      });\n\n    case ActionType.Invalidate:\n      return _extends({}, state, {\n        isInvalidated: true\n      });\n\n    default:\n      return state;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}